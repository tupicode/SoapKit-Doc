"use strict";(self.webpackChunksoap_kit=self.webpackChunksoap_kit||[]).push([[5438],{3597:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"advanced/best-practices","title":"Best Practices","description":"This guide presents battle-tested patterns and practices for building professional games with SoapKit. These recommendations come from real-world projects and help you avoid common pitfalls while maximizing the benefits of the SOAP architecture.","source":"@site/docs/advanced/best-practices.md","sourceDirName":"advanced","slug":"/advanced/best-practices","permalink":"/SoapKit-Doc/docs/advanced/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/advanced/best-practices.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Best Practices","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Performance Optimization","permalink":"/SoapKit-Doc/docs/advanced/performance"},"next":{"title":"Complete Health System","permalink":"/SoapKit-Doc/docs/examples/health-system"}}');var t=a(4848),l=a(8453);const r={title:"Best Practices",sidebar_position:5},s="SoapKit Best Practices",o={},c=[{value:"Architecture Principles",id:"architecture-principles",level:2},{value:"1. Single Responsibility Principle",id:"1-single-responsibility-principle",level:3},{value:"2. Dependency Inversion",id:"2-dependency-inversion",level:3},{value:"Event Design Patterns",id:"event-design-patterns",level:2},{value:"3. Event Naming Conventions",id:"3-event-naming-conventions",level:3},{value:"4. Event Data Design",id:"4-event-data-design",level:3},{value:"5. Event Frequency Management",id:"5-event-frequency-management",level:3},{value:"Variable Management",id:"variable-management",level:2},{value:"6. Variable Scope and Lifetime",id:"6-variable-scope-and-lifetime",level:3},{value:"7. Variable Initialization and Reset",id:"7-variable-initialization-and-reset",level:3},{value:"Memory Management",id:"memory-management",level:2},{value:"8. Event Subscription Lifecycle",id:"8-event-subscription-lifecycle",level:3},{value:"9. Null Safety",id:"9-null-safety",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"10. Efficient Event Listening",id:"10-efficient-event-listening",level:3},{value:"11. Variable Access Patterns",id:"11-variable-access-patterns",level:3},{value:"Debugging and Testing",id:"debugging-and-testing",level:2},{value:"12. Debug-Friendly Design",id:"12-debug-friendly-design",level:3},{value:"13. Testing Strategies",id:"13-testing-strategies",level:3},{value:"Team Collaboration",id:"team-collaboration",level:2},{value:"14. Asset Organization",id:"14-asset-organization",level:3},{value:"15. Documentation Standards",id:"15-documentation-standards",level:3},{value:"Common Anti-Patterns to Avoid",id:"common-anti-patterns-to-avoid",level:2},{value:"16. Over-Engineering",id:"16-over-engineering",level:3},{value:"17. Event Spam",id:"17-event-spam",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"soapkit-best-practices",children:"SoapKit Best Practices"})}),"\n",(0,t.jsx)(n.p,{children:"This guide presents battle-tested patterns and practices for building professional games with SoapKit. These recommendations come from real-world projects and help you avoid common pitfalls while maximizing the benefits of the SOAP architecture."}),"\n",(0,t.jsx)(n.h2,{id:"architecture-principles",children:"Architecture Principles"}),"\n",(0,t.jsx)(n.h3,{id:"1-single-responsibility-principle",children:"1. Single Responsibility Principle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Focused Systems"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Each system has one clear responsibility\npublic class HealthSystem : MonoBehaviour\n{\n    // Only handles health logic - damage, healing, death\n}\n\npublic class HealthUI : MonoBehaviour  \n{\n    // Only handles health-related UI updates\n}\n\npublic class HealthAudio : MonoBehaviour\n{\n    // Only handles health-related audio\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: God Objects"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Violates single responsibility - too many concerns\npublic class PlayerSystem : MonoBehaviour\n{\n    void Update()\n    {\n        HandleMovement();     // Movement concern\n        HandleHealth();       // Health concern  \n        HandleInventory();    // Inventory concern\n        HandleAudio();        // Audio concern\n        HandleUI();          // UI concern\n        // ... this system knows too much!\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-dependency-inversion",children:"2. Dependency Inversion"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Depend on Abstractions"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class WeaponSystem : MonoBehaviour\n{\n    // Depends on SoapKit abstractions, not concrete types\n    [SerializeField] private IntVariable playerHealth;     // Abstract variable\n    [SerializeField] private IntGameEvent onDamageDealt;  // Abstract event\n    \n    public void DealDamage(int damage)\n    {\n        playerHealth.Subtract(damage);    // Uses variable interface\n        onDamageDealt.Raise(damage);     // Uses event interface\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Depend on Concrete Types"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class WeaponSystem : MonoBehaviour\n{\n    // Depends on concrete implementations - tight coupling\n    public HealthSystem healthSystem;     // Concrete dependency\n    public UIManager uiManager;          // Concrete dependency\n    public AudioManager audioManager;    // Concrete dependency\n    \n    public void DealDamage(int damage)\n    {\n        healthSystem.TakeDamage(damage);        // Direct method call\n        uiManager.UpdateHealthDisplay();        // Direct method call\n        audioManager.PlayDamageSound();         // Direct method call\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"event-design-patterns",children:"Event Design Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"3-event-naming-conventions",children:"3. Event Naming Conventions"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Events should be named as past-tense actions or state changes:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good Event Names:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"OnPlayerHealthChanged    // Clear what happened\nOnItemEquipped          // Past tense, specific action\nOnLevelCompleted        // Clear completion event\nOnEnemySpawned          // Specific spawn event\nOnQuestStarted          // Clear beginning event\nOnInventoryFull         // Clear state change\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad Event Names:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"PlayerEvent             // Too generic\nItemStuff               // Unclear purpose\nLevelThing              // Vague naming\nEnemyUpdate             // Present tense, unclear\nQuestEvent              // Not specific enough\nInventoryChange         // What kind of change?\n"})}),"\n",(0,t.jsx)(n.h3,{id:"4-event-data-design",children:"4. Event Data Design"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Use immutable structs for event data:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good Event Data:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"[System.Serializable]\npublic struct DamageEventData\n{\n    public readonly int amount;\n    public readonly DamageType type;\n    public readonly GameObject source;\n    public readonly Vector3 hitPoint;\n    \n    public DamageEventData(int amount, DamageType type, GameObject source, Vector3 hitPoint)\n    {\n        this.amount = amount;\n        this.type = type;\n        this.source = source;\n        this.hitPoint = hitPoint;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad Event Data:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"[System.Serializable]\npublic class BadDamageData\n{\n    public int amount;              // Mutable, can be changed by listeners\n    public string type;             // String instead of enum - error prone\n    public Transform source;        // Can become null unexpectedly\n    public float[] hitData;         // Array - unnecessary complexity\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"5-event-frequency-management",children:"5. Event Frequency Management"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Handle high-frequency events efficiently:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Throttled High-Frequency Events"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class OptimizedMovementEvents : MonoBehaviour\n{\n    [SerializeField] private Vector3GameEvent onPlayerMoved;\n    [SerializeField] private float eventThrottleRate = 0.1f; // 10fps max\n    \n    private float lastEventTime;\n    private Vector3 lastPosition;\n    \n    void Update()\n    {\n        Vector3 currentPosition = transform.position;\n        \n        // Only raise event if enough time has passed and position changed significantly\n        if (Time.time - lastEventTime >= eventThrottleRate && \n            Vector3.Distance(currentPosition, lastPosition) > 0.1f)\n        {\n            onPlayerMoved.Raise(currentPosition);\n            lastEventTime = Time.time;\n            lastPosition = currentPosition;\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Unthrottled High-Frequency Events"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class BadMovementEvents : MonoBehaviour\n{\n    [SerializeField] private Vector3GameEvent onPlayerMoved;\n    \n    void Update()\n    {\n        // Raises event every frame (60+ times per second!)\n        // Can cause performance issues and spam listeners\n        onPlayerMoved.Raise(transform.position);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"variable-management",children:"Variable Management"}),"\n",(0,t.jsx)(n.h3,{id:"6-variable-scope-and-lifetime",children:"6. Variable Scope and Lifetime"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Choose appropriate variable types for different scopes:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Appropriate Variable Scopes"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Global/Persistent Variables - use ScriptableObject variables\n[SerializeField] private IntVariable playerLevel;        // Persists across scenes\n[SerializeField] private StringVariable playerName;      // Global player data\n[SerializeField] private IntVariable totalScore;         // Game-wide score\n\n// Local/Temporary Variables - use regular fields\nprivate float currentAnimationTime;                      // Temporary animation state\nprivate bool isCurrentlyJumping;                        // Temporary movement state\nprivate Vector3 localTargetPosition;                    // Local calculation result\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Wrong Variable Scopes"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Don't use ScriptableObject variables for temporary/local data\n[SerializeField] private FloatVariable animationTime;    // Should be local field\n[SerializeField] private BoolVariable isJumping;        // Should be local field\n[SerializeField] private Vector3Variable tempPosition;   // Should be local field\n"})}),"\n",(0,t.jsx)(n.h3,{id:"7-variable-initialization-and-reset",children:"7. Variable Initialization and Reset"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Handle variable initialization properly:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Proper Variable Initialization"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class GameManager : MonoBehaviour\n{\n    [SerializeField] private IntVariable playerScore;\n    [SerializeField] private BoolVariable isGameActive;\n    [SerializeField] private FloatVariable gameTime;\n    \n    void Start()\n    {\n        InitializeGameVariables();\n    }\n    \n    private void InitializeGameVariables()\n    {\n        // Set initial values explicitly\n        playerScore.SetValue(0);\n        isGameActive.SetValue(false);\n        gameTime.SetValue(0f);\n        \n        // Subscribe to changes after initialization\n        isGameActive.OnValueChanged += OnGameActiveChanged;\n    }\n    \n    public void StartNewGame()\n    {\n        // Reset to initial state\n        playerScore.SetValue(0);\n        gameTime.SetValue(0f);\n        isGameActive.SetValue(true);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Undefined Initialization"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class BadGameManager : MonoBehaviour\n{\n    [SerializeField] private IntVariable playerScore;\n    [SerializeField] private BoolVariable isGameActive;\n    \n    void Start()\n    {\n        // Assumes variables have correct initial values\n        // No explicit initialization - can lead to bugs\n        isGameActive.OnValueChanged += OnGameActiveChanged;\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"memory-management",children:"Memory Management"}),"\n",(0,t.jsx)(n.h3,{id:"8-event-subscription-lifecycle",children:"8. Event Subscription Lifecycle"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Always unsubscribe from events to prevent memory leaks:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Proper Event Lifecycle Management"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class HealthUI : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onHealthChanged;\n    [SerializeField] private UnitGameEvent onPlayerDied;\n    \n    void OnEnable()\n    {\n        // Subscribe when enabled\n        if (onHealthChanged != null)\n            onHealthChanged.AddListener(UpdateHealthDisplay);\n        if (onPlayerDied != null)\n            onPlayerDied.AddListener(ShowDeathScreen);\n    }\n    \n    void OnDisable()\n    {\n        // Always unsubscribe when disabled\n        if (onHealthChanged != null)\n            onHealthChanged.RemoveListener(UpdateHealthDisplay);\n        if (onPlayerDied != null)\n            onPlayerDied.RemoveListener(ShowDeathScreen);\n    }\n    \n    private void UpdateHealthDisplay(int health) { /* Update UI */ }\n    private void ShowDeathScreen() { /* Show death UI */ }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Missing Unsubscribe"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class BadHealthUI : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onHealthChanged;\n    \n    void Start()\n    {\n        // Subscribe but never unsubscribe\n        onHealthChanged.AddListener(UpdateHealthDisplay);\n        // Memory leak! Event holds reference to this object even after destruction\n    }\n    \n    private void UpdateHealthDisplay(int health) { /* Update UI */ }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"9-null-safety",children:"9. Null Safety"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Always check for null references:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Null-Safe Event Handling"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class SafeEventHandler : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onScoreChanged;\n    \n    void OnEnable()\n    {\n        if (onScoreChanged != null)\n            onScoreChanged.AddListener(OnScoreChanged);\n    }\n    \n    void OnDisable()\n    {\n        // Null check prevents errors during shutdown\n        if (onScoreChanged != null)\n            onScoreChanged.RemoveListener(OnScoreChanged);\n    }\n    \n    private void OnScoreChanged(int score)\n    {\n        // Additional null checks for referenced objects\n        if (scoreText != null)\n            scoreText.text = score.ToString();\n    }\n    \n    public void RaiseScoreEvent(int score)\n    {\n        // Null check before raising\n        if (onScoreChanged != null)\n            onScoreChanged.Raise(score);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: No Null Checking"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class UnsafeEventHandler : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onScoreChanged;\n    \n    void OnEnable()\n    {\n        // Will throw NullReferenceException if onScoreChanged is null\n        onScoreChanged.AddListener(OnScoreChanged);\n    }\n    \n    void OnDisable()\n    {\n        // Will throw NullReferenceException during shutdown\n        onScoreChanged.RemoveListener(OnScoreChanged);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"10-efficient-event-listening",children:"10. Efficient Event Listening"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Optimize event listeners for performance:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Efficient Event Listeners"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class OptimizedListener : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onHealthChanged;\n    \n    // Cache expensive lookups\n    private Text healthText;\n    private Image healthBar;\n    private int cachedHealth = -1;\n    \n    void Start()\n    {\n        // Cache UI references once\n        healthText = GetComponent<Text>();\n        healthBar = GetComponent<Image>();\n    }\n    \n    void OnEnable()\n    {\n        onHealthChanged.AddListener(OnHealthChanged);\n    }\n    \n    void OnDisable()\n    {\n        if (onHealthChanged != null)\n            onHealthChanged.RemoveListener(OnHealthChanged);\n    }\n    \n    private void OnHealthChanged(int newHealth)\n    {\n        // Only update if value actually changed\n        if (cachedHealth == newHealth) return;\n        cachedHealth = newHealth;\n        \n        // Use cached references\n        if (healthText != null)\n            healthText.text = newHealth.ToString();\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Inefficient Event Listeners"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class SlowListener : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onHealthChanged;\n    \n    void OnEnable()\n    {\n        onHealthChanged.AddListener(OnHealthChanged);\n    }\n    \n    private void OnHealthChanged(int newHealth)\n    {\n        // Expensive operations on every event\n        var healthText = FindObjectOfType<Text>();  // Slow search\n        var healthBar = GameObject.Find("HealthBar").GetComponent<Image>(); // Slow search\n        \n        // Update even if value hasn\'t changed\n        healthText.text = newHealth.ToString();\n        healthBar.fillAmount = newHealth / 100f;\n        \n        // Unnecessary expensive operations\n        Resources.UnloadUnusedAssets();  // Very expensive!\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"11-variable-access-patterns",children:"11. Variable Access Patterns"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Optimize variable access for performance:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Cached Variable Access"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class EfficientVariableUser : MonoBehaviour\n{\n    [SerializeField] private IntVariable playerHealth;\n    [SerializeField] private FloatVariable moveSpeed;\n    \n    // Cache values when they change\n    private int cachedHealth;\n    private float cachedSpeed;\n    \n    void Start()\n    {\n        // Cache initial values\n        cachedHealth = playerHealth.Value;\n        cachedSpeed = moveSpeed.Value;\n        \n        // Subscribe to changes to update cache\n        playerHealth.OnValueChanged += (h) => cachedHealth = h;\n        moveSpeed.OnValueChanged += (s) => cachedSpeed = s;\n    }\n    \n    void Update()\n    {\n        // Use cached values in performance-critical code\n        if (cachedHealth <= 0)\n            HandleDeath();\n            \n        transform.Translate(Vector3.forward * cachedSpeed * Time.deltaTime);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Repeated Variable Access"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"public class SlowVariableUser : MonoBehaviour\n{\n    [SerializeField] private IntVariable playerHealth;\n    [SerializeField] private FloatVariable moveSpeed;\n    \n    void Update()\n    {\n        // Accesses .Value multiple times per frame - inefficient\n        if (playerHealth.Value <= 0)\n            HandleDeath();\n            \n        if (playerHealth.Value < 25)\n            ShowLowHealthWarning();\n            \n        transform.Translate(Vector3.forward * moveSpeed.Value * Time.deltaTime);\n        \n        // Even worse - accessing in nested loops\n        for (int i = 0; i < enemies.Length; i++)\n        {\n            if (Vector3.Distance(enemies[i].position, transform.position) < moveSpeed.Value)\n            {\n                // Accessing moveSpeed.Value inside loop!\n            }\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"debugging-and-testing",children:"Debugging and Testing"}),"\n",(0,t.jsx)(n.h3,{id:"12-debug-friendly-design",children:"12. Debug-Friendly Design"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Design systems to be easily debuggable:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Debug-Friendly Implementation"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class DebuggableHealthSystem : MonoBehaviour\n{\n    [Header("Debug Info")]\n    [SerializeField] private bool enableDebugLogging = true;\n    [SerializeField] private bool showDebugGUI = false;\n    \n    [Header("Health Data")]\n    [SerializeField] private IntVariable currentHealth;\n    [SerializeField] private IntGameEvent onHealthChanged;\n    \n    public void TakeDamage(int damage, string source = "unknown")\n    {\n        if (enableDebugLogging)\n            Debug.Log($"[HealthSystem] Taking {damage} damage from {source}. Health: {currentHealth.Value} -> {currentHealth.Value - damage}");\n        \n        int newHealth = Mathf.Max(0, currentHealth.Value - damage);\n        currentHealth.SetValue(newHealth);\n        onHealthChanged.Raise(newHealth);\n        \n        if (enableDebugLogging && newHealth <= 0)\n            Debug.Log($"[HealthSystem] Player died from {source}");\n    }\n    \n    // Debug methods accessible from inspector\n    [ContextMenu("Debug: Take 25 Damage")]\n    private void DebugTakeDamage() => TakeDamage(25, "debug");\n    \n    [ContextMenu("Debug: Heal to Full")]\n    private void DebugHealFull() => currentHealth.SetValue(100);\n    \n    [ContextMenu("Debug: Log Health Status")]\n    private void DebugLogStatus() => Debug.Log($"Health: {currentHealth.Value}/100");\n    \n    #if UNITY_EDITOR\n    void OnGUI()\n    {\n        if (!showDebugGUI || !Application.isPlaying) return;\n        \n        GUILayout.BeginArea(new Rect(10, 10, 200, 100));\n        GUILayout.Label($"Health: {currentHealth.Value}");\n        if (GUILayout.Button("Damage 25")) TakeDamage(25, "debug");\n        if (GUILayout.Button("Heal Full")) currentHealth.SetValue(100);\n        GUILayout.EndArea();\n    }\n    #endif\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Hard to Debug"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class HardToDebugSystem : MonoBehaviour\n{\n    [SerializeField] private IntVariable h; // Unclear naming\n    [SerializeField] private IntGameEvent e; // Unclear naming\n    \n    public void D(int d) // Unclear method name\n    {\n        // No logging, no feedback\n        h.SetValue(h.Value - d);\n        e.Raise(h.Value);\n        \n        if (h.Value <= 0)\n        {\n            // Magic happens with no explanation\n            GameObject.Find("Player").SetActive(false);\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"13-testing-strategies",children:"13. Testing Strategies"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Design for testability:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Testable Design"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:'public class TestableInventorySystem : MonoBehaviour\n{\n    [SerializeField] private IntVariable itemCount;\n    [SerializeField] private IntVariable capacity;\n    [SerializeField] private StringGameEvent onItemAdded;\n    \n    // Exposed properties for testing\n    public int ItemCount => itemCount.Value;\n    public int Capacity => capacity.Value;\n    public bool IsFull => itemCount.Value >= capacity.Value;\n    \n    // Clear interface methods\n    public bool TryAddItem(string itemName)\n    {\n        if (IsFull) return false;\n        \n        itemCount.Increment();\n        onItemAdded.Raise(itemName);\n        return true;\n    }\n    \n    public void RemoveItem()\n    {\n        if (itemCount.Value > 0)\n            itemCount.Decrement();\n    }\n    \n    // Test helper methods\n    public void ClearInventory() => itemCount.SetValue(0);\n    public void SetCapacity(int newCapacity) => capacity.SetValue(newCapacity);\n}\n\n// Corresponding test\n[Test]\npublic void TestInventorySystem()\n{\n    var system = CreateTestInventorySystem();\n    \n    Assert.IsTrue(system.TryAddItem("Sword"));\n    Assert.AreEqual(1, system.ItemCount);\n    Assert.IsFalse(system.IsFull);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"team-collaboration",children:"Team Collaboration"}),"\n",(0,t.jsx)(n.h3,{id:"14-asset-organization",children:"14. Asset Organization"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Organize SoapKit assets for team collaboration:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Organized Asset Structure"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Assets/\n\u251c\u2500\u2500 Data/\n\u2502   \u251c\u2500\u2500 Variables/\n\u2502   \u2502   \u251c\u2500\u2500 Player/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Combat/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 PlayerHealth.asset\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 PlayerMana.asset\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 PlayerStamina.asset\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 Progression/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 PlayerLevel.asset\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 PlayerExperience.asset\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 PlayerSkillPoints.asset\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 Social/\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 PlayerName.asset\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 GuildName.asset\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 FriendsList.asset\n\u2502   \u2502   \u251c\u2500\u2500 Game/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 GameScore.asset\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 GameTime.asset\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 CurrentLevel.asset\n\u2502   \u2502   \u2514\u2500\u2500 UI/\n\u2502   \u2502       \u251c\u2500\u2500 MenuIndex.asset\n\u2502   \u2502       \u251c\u2500\u2500 VolumeLevel.asset\n\u2502   \u2502       \u2514\u2500\u2500 ScreenBrightness.asset\n\u2502   \u2514\u2500\u2500 Events/\n\u2502       \u251c\u2500\u2500 Player/\n\u2502       \u2502   \u251c\u2500\u2500 OnPlayerDied.asset\n\u2502       \u2502   \u251c\u2500\u2500 OnPlayerLevelUp.asset\n\u2502       \u2502   \u2514\u2500\u2500 OnPlayerJoined.asset\n\u2502       \u251c\u2500\u2500 Game/\n\u2502       \u2502   \u251c\u2500\u2500 OnGameStart.asset\n\u2502       \u2502   \u251c\u2500\u2500 OnGamePause.asset\n\u2502       \u2502   \u2514\u2500\u2500 OnLevelComplete.asset\n\u2502       \u2514\u2500\u2500 UI/\n\u2502           \u251c\u2500\u2500 OnMenuChanged.asset\n\u2502           \u2514\u2500\u2500 OnButtonClicked.asset\n"})}),"\n",(0,t.jsx)(n.h3,{id:"15-documentation-standards",children:"15. Documentation Standards"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Document your SOAP architecture:"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Well-Documented System"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"/// <summary>\n/// Manages player health including damage, healing, regeneration, and death.\n/// \n/// Dependencies:\n/// - PlayerHealth (IntVariable): Current health value\n/// - MaxHealth (IntVariable): Maximum possible health\n/// - OnHealthChanged (IntGameEvent): Raised when health changes\n/// - OnPlayerDied (UnitGameEvent): Raised when player dies\n/// \n/// Events Raised:\n/// - OnHealthChanged: When health value changes\n/// - OnPlayerDied: When health reaches 0\n/// - OnRegenStarted: When health regeneration begins\n/// \n/// Events Listened To:\n/// - None (this system is autonomous)\n/// \n/// Usage:\n/// - TakeDamage(amount): Applies damage to player\n/// - Heal(amount): Heals player by specified amount\n/// - SetInvulnerable(bool): Toggles damage immunity\n/// </summary>\npublic class HealthSystem : MonoBehaviour\n{\n    // Implementation...\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Undocumented System"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// No documentation about what this does or how it works\npublic class HealthSystem : MonoBehaviour\n{\n    // Mystery variables with no explanation\n    [SerializeField] private IntVariable h;\n    [SerializeField] private IntGameEvent e1;\n    [SerializeField] private UnitGameEvent e2;\n    \n    // Implementation with no comments...\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-anti-patterns-to-avoid",children:"Common Anti-Patterns to Avoid"}),"\n",(0,t.jsx)(n.h3,{id:"16-over-engineering",children:"16. Over-Engineering"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Over-Complicated for Simple Needs"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Don't create SOAP variables for every single value\npublic class OverEngineeredButton : MonoBehaviour\n{\n    [SerializeField] private BoolVariable isButtonHovered;     // Overkill\n    [SerializeField] private BoolVariable isButtonPressed;     // Overkill\n    [SerializeField] private FloatVariable buttonAlpha;       // Overkill\n    [SerializeField] private Vector2Variable buttonSize;      // Overkill\n    [SerializeField] private ColorVariable buttonColor;       // Overkill\n    \n    // This should just be a regular Unity Button with Animator\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Appropriate Scope"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Only use SOAP for data that needs to be shared across systems\npublic class AppropriateButton : MonoBehaviour\n{\n    [SerializeField] private StringGameEvent onButtonClicked; // Good - other systems need this\n    \n    // Local button state doesn't need SOAP variables\n    private bool isHovered;\n    private bool isPressed;\n    private float currentAlpha;\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"17-event-spam",children:"17. Event Spam"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u274c Bad: Too Many Granular Events"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Don't create separate events for every tiny thing\npublic class EventSpammer : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onHealthChanged1;\n    [SerializeField] private IntGameEvent onHealthChanged2;\n    [SerializeField] private IntGameEvent onHealthChanged3;\n    [SerializeField] private IntGameEvent onHealthIncreasedBy1;\n    [SerializeField] private IntGameEvent onHealthIncreasedBy5;\n    [SerializeField] private IntGameEvent onHealthIncreasedBy10;\n    // ... way too many events!\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"\u2705 Good: Appropriate Event Granularity"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-csharp",children:"// Use fewer, more meaningful events\npublic class AppropriateEvents : MonoBehaviour\n{\n    [SerializeField] private IntGameEvent onHealthChanged;     // General health change\n    [SerializeField] private IntGameEvent onDamageTaken;      // Specific damage event\n    [SerializeField] private IntGameEvent onHealthHealed;     // Specific heal event\n    [SerializeField] private UnitGameEvent onPlayerDied;     // Critical state change\n}\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["Following these best practices will help you build robust, maintainable, and professional games with SoapKit. Remember: ",(0,t.jsx)(n.strong,{children:"start simple and evolve complexity as needed"}),". The SOAP architecture's strength lies in its ability to scale gracefully as your project grows. \ud83c\udfd7\ufe0f\u2728"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Key Principles Summary:"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Single Responsibility"})," - One concern per system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Null Safety"})," - Always check for null references"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Memory Management"})," - Subscribe and unsubscribe properly"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"})," - Cache values, throttle high-frequency events"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Debuggability"})," - Make systems easy to inspect and test"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation"})," - Document dependencies and interactions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Team Collaboration"})," - Organize assets logically"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Next Steps:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Review your existing code against these practices"}),"\n",(0,t.jsx)(n.li,{children:"Set up coding standards for your team"}),"\n",(0,t.jsx)(n.li,{children:"Create templates that follow these patterns"}),"\n",(0,t.jsx)(n.li,{children:"Regular code reviews focusing on SOAP architecture"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By following these practices, you'll create Unity games that are not just functional, but professional, maintainable, and scalable! \ud83c\udfae\ud83d\ude80"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>s});var i=a(6540);const t={},l=i.createContext(t);function r(e){const n=i.useContext(l);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);